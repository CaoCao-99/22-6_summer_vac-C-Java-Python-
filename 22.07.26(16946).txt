22.07.26: 16946 풀기
16946 문제 내용{

  벽 부수고 이동하기 4

N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다.

 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.

각각의 벽에 대해서 다음을 구해보려고 한다.

벽을 부수고 이동할 수 있는 곳으로 변경한다.

그 위치에서 이동할 수 있는 칸의 개수를 세어본다.

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

}

입력{

첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.

 }

출력{

맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.

}

DFS를 이용하여 해결 할 수 있는 문제다. 

상하좌우로 이동이 가능하며 0이 있는 공간에서는 자유롭게 이동이 가능하기 때문에 0의 개수를 세주면 된다.

단, 주의할 점은 같은 0을 여러번 세면 안되는 것이다. 따라서, 모든 0을 for 구문을 이용하여 확인한 이후에 cnt++ 값을 벽에 해당하는 공간에 더해주면 된다.

따라서, for 구문 안에 2 가지의 if 문을 넣으면 된다. 1. board[i][j] == 0 - > cnt++; visit[i][j] = true; DFS(i, j) 2. board[i][j] !=0  v.push_back({i,j}); visit[i][j] = true;

이후에 for 구문 밖에서 v의 사이즈를 이용하여 값을 더해주면 된다.

느낀점{
    DFS를 사용했지만 Q를 이용하여 문제를 해결해야 했다. 

    q의 값이 비었는지를 확인하여 재귀적으로 문제를 해결하였다.(실제로 재귀 함수를 사용하지는 않았다.)

    if 문을 사용할 때 특히, or 을 이용할때는 배열의 index값이 초과 할 수 있기에 마지막에 놓는 것이 안전하다.

    java의 경우 여전히 문법이 약하기 때문에 동적 할당 배열인 List를 자주 사용해야 할 것 같다.(List <> l = new ArrayList<>(), Queue <> q = new LinkedList<>()) 

    또한, java의 경우 같은 방법으로 문제를 풀면 시간초과가 발생하였다. 

    Python의 경우는 내일 java에서 푼 방법을 익힌 후에 다시 풀어봐야겠다.

    22.07.27 Python 언어를 이용하여 문제를 해결 하였으며 Block을 사용하지 않고 들여쓰기를 사용하기 때문에

    앞으로 Python을 이용할 때 이 부분을 주의해야 할 것 같다.
}